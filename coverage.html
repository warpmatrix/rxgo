
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rxgo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/warpmatrix/rxgo/filter.go (86.1%)</option>
				
				<option value="file1">github.com/warpmatrix/rxgo/generators.go (93.0%)</option>
				
				<option value="file2">github.com/warpmatrix/rxgo/rxgo.go (84.0%)</option>
				
				<option value="file3">github.com/warpmatrix/rxgo/transforms.go (83.3%)</option>
				
				<option value="file4">github.com/warpmatrix/rxgo/utility.go (61.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rxgo

import (
        "container/list"
        "context"
        "reflect"
        "time"
)

// filter node implementation of streamOperator
type filtOperator struct {
        opFunc func(ctx context.Context, o *Observable, in chan interface{}, out chan interface{}) (end bool)
}

func (fop filtOperator) op(ctx context.Context, o *Observable) <span class="cov8" title="1">{
        in := o.pred.outflow
        out := o.outflow

        // Scheduler
        go func() </span><span class="cov8" title="1">{
                fop.opFunc(ctx, o, in, out)
                o.closeFlow(out)
        }</span>()
}

// Debounce only emit an item from an Observable if a particular timespan has passed without it emitting another item
func (parent *Observable) Debounce(timespan time.Duration) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("debounce")
        o.flip = func(ctx context.Context, in chan interface{}, out chan interface{}) (end bool) </span><span class="cov8" title="1">{
                var latest reflect.Value
                go func() </span><span class="cov8" title="1">{
                        for !end </span><span class="cov8" title="1">{
                                than := time.After(timespan)
                                &lt;-than
                                if latest != reflect.ValueOf(nil) </span><span class="cov8" title="1">{
                                        if o.sendToFlow(ctx, latest.Interface(), out) </span><span class="cov0" title="0">{
                                                end = true
                                        }</span>
                                        <span class="cov8" title="1">latest = reflect.ValueOf(nil)</span>
                                }
                        }
                }()

                <span class="cov8" title="1">for !end </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                end = true</span>
                        case item, ok := &lt;-in:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        end = true
                                }</span>
                                <span class="cov8" title="1">latest = reflect.ValueOf(item)</span>
                        }
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">o.operator = debounceOperator
        return o</span>
}

var debounceOperator = defaultOperator

// used in distinct operator
type cmpKeyFunc func(interface{}) interface{}

// Distinct suppress duplicate items emitted by an Observable
func (parent *Observable) Distinct(f cmpKeyFunc) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("distinct")
        o.flip = f
        o.operator = distinctOperator
        return o
}</span>

var distinctOperator = filtOperator{func(ctx context.Context, o *Observable, in chan interface{}, out chan interface{}) (end bool) <span class="cov8" title="1">{
        keyset := make(map[interface{}]struct{})
        fv := o.flip.(cmpKeyFunc)
        for !end </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        end = true</span>
                case item, ok := &lt;-in:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                end = true
                                break</span>
                        }
                        <span class="cov8" title="1">itemVal := reflect.ValueOf(item)
                        key := fv(itemVal.Interface())
                        _, hasKey := keyset[key]
                        if !hasKey </span><span class="cov8" title="1">{
                                keyset[key] = struct{}{}
                                if o.sendToFlow(ctx, itemVal.Interface(), out) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}}

// ElementAt emit only item n emitted by an Observable
func (parent *Observable) ElementAt(n uint) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("ElementAt")
        o.flip = func(ctx context.Context, in chan interface{}, out chan interface{}) (end bool) </span><span class="cov8" title="1">{
                i := uint(0)
                for !end </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                end = true</span>
                        case item, ok := &lt;-in:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        end = true
                                        break</span>
                                }
                                <span class="cov8" title="1">itemVal := reflect.ValueOf(item)
                                if i == n </span><span class="cov8" title="1">{
                                        if o.sendToFlow(ctx, itemVal.Interface(), out) </span><span class="cov0" title="0">{
                                                end = true
                                                return
                                        }</span>
                                }
                                <span class="cov8" title="1">i++</span>
                        }
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">o.operator = elementAtOperator
        return o</span>
}

var elementAtOperator = defaultOperator

// IgnoreElements do not emit any items from an Observable but mirror its termination notification
func (parent *Observable) IgnoreElements() (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("IgnoreElements")
        o.operator = ignoreElementsOperator
        return o
}</span>

var ignoreElementsOperator = filtOperator{func(ctx context.Context, o *Observable, in chan interface{}, out chan interface{}) (end bool) <span class="cov8" title="1">{
        for !end </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        end = true</span>
                case _, ok := &lt;-in:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                end = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}}

// First emit only the first item, or the first item that meets a condition, from an Observable
func (parent *Observable) First(f interface{}) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("First")
        fv := reflect.ValueOf(f)
        inType := []reflect.Type{typeAny}
        outType := []reflect.Type{typeBool}
        b, ctxSup := checkFuncUpcast(fv, inType, outType, true)
        if !b </span><span class="cov0" title="0">{
                panic(ErrFuncFlip)</span>
        }
        <span class="cov8" title="1">o.flip_accept_error = checkFuncAcceptError(fv)
        o.flip_sup_ctx = ctxSup
        o.flip = fv.Interface()
        o.operator = firstOperator
        return o</span>
}

var firstOperator = filtOperator{func(ctx context.Context, o *Observable, in chan interface{}, out chan interface{}) (end bool) <span class="cov8" title="1">{
        fv := reflect.ValueOf(o.flip)
        for x := range in </span><span class="cov8" title="1">{
                if end </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">xv := reflect.ValueOf(x)
                params := []reflect.Value{xv}
                rs, skip, stop, e := userFuncCall(fv, params)
                var item interface{} = rs[0].Interface()
                if stop </span><span class="cov0" title="0">{
                        end = true
                        continue</span>
                }
                <span class="cov8" title="1">if skip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if e != nil </span><span class="cov0" title="0">{
                        item = e
                }</span>
                // send data
                <span class="cov8" title="1">if !end </span><span class="cov8" title="1">{
                        if b, ok := item.(bool); ok &amp;&amp; b </span><span class="cov8" title="1">{
                                o.sendToFlow(ctx, xv.Interface(), out)
                                end = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}}

// Last emit only the last item emitted by an Observable
func (parent *Observable) Last(f interface{}) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("Last")
        fv := reflect.ValueOf(f)
        inType := []reflect.Type{typeAny}
        outType := []reflect.Type{typeBool}
        b, ctxSup := checkFuncUpcast(fv, inType, outType, true)
        if !b </span><span class="cov0" title="0">{
                panic(ErrFuncFlip)</span>
        }
        <span class="cov8" title="1">o.flip_accept_error = checkFuncAcceptError(fv)
        o.flip_sup_ctx = ctxSup
        o.flip = fv.Interface()
        o.operator = lastOperator
        return o</span>
}

var lastOperator = filtOperator{func(ctx context.Context, o *Observable, in chan interface{}, out chan interface{}) (end bool) <span class="cov8" title="1">{
        fv := reflect.ValueOf(o.flip)
        var last reflect.Value
        for x := range in </span><span class="cov8" title="1">{
                if end </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">xv := reflect.ValueOf(x)
                params := []reflect.Value{xv}
                rs, skip, stop, e := userFuncCall(fv, params)
                var item interface{} = rs[0].Interface()
                if stop </span><span class="cov0" title="0">{
                        end = true
                        continue</span>
                }
                <span class="cov8" title="1">if skip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if e != nil </span><span class="cov0" title="0">{
                        item = e
                }</span>
                // send data
                <span class="cov8" title="1">if !end </span><span class="cov8" title="1">{
                        if b, ok := item.(bool); ok &amp;&amp; b </span><span class="cov8" title="1">{
                                last = xv
                        }</span>
                }
        }
        <span class="cov8" title="1">if last != reflect.ValueOf(nil) </span><span class="cov8" title="1">{
                end = o.sendToFlow(ctx, last.Interface(), out)
        }</span>
        <span class="cov8" title="1">return</span>
}}

// Sample emit the most recent item emitted by an Observable within periodic time intervals
func (parent *Observable) Sample(smpChan chan interface{}) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("Sample")
        o.flip = func(ctx context.Context, in chan interface{}, out chan interface{}) (end bool) </span><span class="cov8" title="1">{
                var latest reflect.Value
                for !end </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                end = true</span>
                        case item, ok := &lt;-in:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        end = true
                                        break</span>
                                }
                                <span class="cov8" title="1">latest = reflect.ValueOf(item)</span>
                        case &lt;-smpChan:<span class="cov8" title="1">
                                if latest != reflect.ValueOf(nil) </span><span class="cov8" title="1">{
                                        if o.sendToFlow(ctx, latest.Interface(), out) </span><span class="cov0" title="0">{
                                                end = true
                                                return
                                        }</span>
                                        <span class="cov8" title="1">latest = reflect.ValueOf(nil)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">o.operator = sampleOperator
        return o</span>
}

var sampleOperator = defaultOperator

// Skip suppress the first n items emitted by an Observable
func (parent *Observable) Skip(n int) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("Skip")
        o.flip = func(ctx context.Context, in chan interface{}, out chan interface{}) (end bool) </span><span class="cov8" title="1">{
                i := 0
                for !end </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                end = true</span>
                        case item, ok := &lt;-in:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        end = true
                                        break</span>
                                }
                                <span class="cov8" title="1">if i &lt; n </span><span class="cov8" title="1">{
                                        i++
                                        continue</span>
                                }
                                <span class="cov8" title="1">xVal := reflect.ValueOf(item)
                                if o.sendToFlow(ctx, xVal.Interface(), out) </span><span class="cov0" title="0">{
                                        end = true
                                        return
                                }</span>
                        }
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">o.operator = skipOperator
        return o</span>
}

var skipOperator = defaultOperator

// SkipLast suppress the last n items emitted by an Observable
func (parent *Observable) SkipLast(n int) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("SkipLast")
        o.flip = func(ctx context.Context, in chan interface{}, out chan interface{}) (end bool) </span><span class="cov8" title="1">{
                q := list.New()
                for !end </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                end = true</span>
                        case item, ok := &lt;-in:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        end = true
                                        break</span>
                                }
                                <span class="cov8" title="1">q.PushBack(item)
                                if q.Len() &gt; n </span><span class="cov8" title="1">{
                                        x := q.Front()
                                        xVal := reflect.ValueOf(x.Value)
                                        if o.sendToFlow(ctx, xVal.Interface(), out) </span><span class="cov0" title="0">{
                                                end = true
                                                return
                                        }</span>
                                        <span class="cov8" title="1">q.Remove(x)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">o.operator = skipLastOperator
        return o</span>
}

var skipLastOperator = defaultOperator

// Take emit only the first n items emitted by an Observable
func (parent *Observable) Take(n int) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("Take")
        o.flip = func(ctx context.Context, in chan interface{}, out chan interface{}) (end bool) </span><span class="cov8" title="1">{
                i := 0
                for !end </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                end = true</span>
                        case item, ok := &lt;-in:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        end = true
                                        break</span>
                                }
                                <span class="cov8" title="1">if i &lt; n </span><span class="cov8" title="1">{
                                        i++
                                        xVal := reflect.ValueOf(item)
                                        if o.sendToFlow(ctx, xVal.Interface(), out) </span><span class="cov0" title="0">{
                                                end = true
                                                return
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">o.operator = skipOperator
        return o</span>
}

var takeOperator = defaultOperator

// TakeLast emit only the last n items emitted by an Observable
func (parent *Observable) TakeLast(n int) (o *Observable) <span class="cov8" title="1">{
        o = parent.newFilterObservable("TakeLast")
        o.flip = func(ctx context.Context, in chan interface{}, out chan interface{}) (end bool) </span><span class="cov8" title="1">{
                q := list.New()
                for !end </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                end = true</span>
                        case item, ok := &lt;-in:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        end = true
                                        break</span>
                                }
                                <span class="cov8" title="1">q.PushBack(item)
                                if q.Len() &gt; n </span><span class="cov8" title="1">{
                                        x := q.Front()
                                        q.Remove(x)
                                }</span>
                        }
                }
                <span class="cov8" title="1">for x := q.Front(); x != nil; x = x.Next() </span><span class="cov8" title="1">{
                        xVal := reflect.ValueOf(x.Value)
                        if o.sendToFlow(ctx, xVal.Interface(), out) </span><span class="cov0" title="0">{
                                end = true
                                return
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">o.operator = takeLastOperator
        return o</span>
}

var takeLastOperator = defaultOperator

func (parent *Observable) newFilterObservable(name string) (o *Observable) <span class="cov8" title="1">{
        //new Observable
        o = newObservable()
        o.Name = name
        //chain Observables
        parent.next = o
        o.pred = parent
        o.root = parent.root
        return o
}</span>

var defaultOperator = filtOperator{func(ctx context.Context, o *Observable, in chan interface{}, out chan interface{}) (end bool) <span class="cov8" title="1">{
        fv := reflect.ValueOf(o.flip)
        params := []reflect.Value{reflect.ValueOf(ctx), reflect.ValueOf(in), reflect.ValueOf(out)}
        fv.Call(params)
        return true
}</span>}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2018 The SS.SYSU Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rxgo

import (
        "context"
        "reflect"
)

// source node implementation of streamOperator
type sourceOperater struct {
        opFunc func(ctx context.Context, o *Observable, out chan interface{}) (end bool)
}

func (sop sourceOperater) op(ctx context.Context, o *Observable) <span class="cov8" title="1">{
        // must hold defintion of flow resourcs here, such as chan etc., that is allocated when connected
        // this resurces may be changed when operation routine is running.
        out := o.outflow
        //fmt.Println(o.name, "source out chan ", out)

        // Scheduler
        go func() </span><span class="cov8" title="1">{
                sop.opFunc(ctx, o, out)
                o.closeFlow(out)
        }</span>()
}

func Generator(sf sourceFunc) *Observable <span class="cov8" title="1">{
        o := newGeneratorObservable("CustomSource")
        o.flip = sf
        o.operator = sourceSource
        return o
}</span>

var sourceSource = sourceOperater{func(ctx context.Context, o *Observable, out chan interface{}) (end bool) <span class="cov8" title="1">{
        sf := o.flip.(sourceFunc)
        send := func(x interface{}) (endSignal bool) </span><span class="cov8" title="1">{
                endSignal = o.sendToFlow(ctx, x, out)
                return
        }</span>
        <span class="cov8" title="1">sf(ctx, send)
        return true</span>
}}

// creates an Observable with the provided item(s) producing by the function `func()  (val anytype, end bool)`
func Start(f interface{}) *Observable <span class="cov8" title="1">{
        fv := reflect.ValueOf(f)
        inType := []reflect.Type{}
        outType := []reflect.Type{typeAny, typeBool}
        ctx_sup := false
        if b, cb := checkFuncUpcast(fv, inType, outType, true); !b </span><span class="cov0" title="0">{
                panic(ErrFuncFlip)</span>
        } else<span class="cov8" title="1"> {
                ctx_sup = cb
        }</span>

        <span class="cov8" title="1">o := newGeneratorObservable("Start")
        o.flip_sup_ctx = ctx_sup

        o.flip = fv.Interface()
        o.operator = startSource
        return o</span>
}

var startSource = sourceOperater{func(ctx context.Context, o *Observable, out chan interface{}) (end bool) <span class="cov8" title="1">{
        fv := reflect.ValueOf(o.flip)
        params := []reflect.Value{}
        if o.flip_sup_ctx </span><span class="cov8" title="1">{
                params = []reflect.Value{reflect.ValueOf(ctx)}
        }</span>

        <span class="cov8" title="1">for end := false; !end; </span><span class="cov8" title="1">{
                rs, skip, stop, e := userFuncCall(fv, params)

                var item interface{}
                if stop </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">if skip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if e != nil </span><span class="cov8" title="1">{
                        item = e
                }</span>
                <span class="cov8" title="1">if len(rs) &gt; 0 </span><span class="cov8" title="1">{
                        end, _ = (rs[1].Interface()).(bool)
                        item = rs[0].Interface()
                }</span>
                // send data
                <span class="cov8" title="1">if !end </span><span class="cov8" title="1">{
                        end = o.sendToFlow(ctx, item, out)
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}}

// Range creates an Observable that emits a particular range of sequential integers.
func Range(start, end int) *Observable <span class="cov8" title="1">{
        o := newGeneratorObservable("Range")

        o.flip = func(ctx context.Context, out chan interface{}) </span><span class="cov8" title="1">{
                i := start
                for i &lt; end </span><span class="cov8" title="1">{
                        if b := o.sendToFlow(ctx, i, out); b </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
        <span class="cov8" title="1">o.operator = rangeSource
        return o</span>
}

var rangeSource = sourceOperater{func(ctx context.Context, o *Observable, out chan interface{}) (end bool) <span class="cov8" title="1">{
        fv := reflect.ValueOf(o.flip)
        params := []reflect.Value{reflect.ValueOf(ctx), reflect.ValueOf(out)}
        fv.Call(params)
        return true
}</span>}

// Just creates an Observable with the provided item(s).
func Just(items ...interface{}) *Observable <span class="cov8" title="1">{
        o := newGeneratorObservable("Just")

        o.flip = func(ctx context.Context, out chan interface{}) </span><span class="cov8" title="1">{
                for _, item := range items </span><span class="cov8" title="1">{
                        if b := o.sendToFlow(ctx, item, out); b </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">o.operator = justSource
        return o</span>
}

var justSource = rangeSource
var fromSlice = rangeSource
var fromChannel = rangeSource
var fromObservable = rangeSource

// convert Slice, Channel, and Observable into Observables
func From(items interface{}) *Observable <span class="cov8" title="1">{
        v, t := reflect.ValueOf(items), reflect.TypeOf(items)

        if v.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                length := v.Len()
                o := newGeneratorObservable("From Slice")

                o.flip = func(ctx context.Context, out chan interface{}) </span><span class="cov8" title="1">{
                        i := 0
                        for i &lt; length </span><span class="cov8" title="1">{
                                item := v.Index(i).Interface()
                                if b := o.sendToFlow(ctx, item, out); b </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">i++</span>
                        }
                }
                <span class="cov8" title="1">o.operator = fromSlice
                return o</span>
        }

        <span class="cov8" title="1">if v.Kind() == reflect.Chan </span><span class="cov8" title="1">{
                o := newGeneratorObservable("From Channel")

                o.flip = func(ctx context.Context, out chan interface{}) </span><span class="cov8" title="1">{
                        for </span><span class="cov8" title="1">{
                                // details: https://godoc.org/reflect#Select
                                var selectcases = []reflect.SelectCase{
                                        reflect.SelectCase{Dir: reflect.SelectRecv, Chan: v},
                                        reflect.SelectCase{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(ctx.Done())},
                                }
                                chosen, recv, recvOK := reflect.Select(selectcases)
                                if !recvOK </span><span class="cov8" title="1">{
                                        return
                                }</span>
                                <span class="cov8" title="1">switch chosen </span>{
                                case 0:<span class="cov8" title="1"></span>
                                case 1:<span class="cov0" title="0">
                                        return</span>
                                }
                                <span class="cov8" title="1">item := recv.Interface()
                                if b := o.sendToFlow(ctx, item, out); b </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov8" title="1">o.operator = fromChannel
                return o</span>
        }

        <span class="cov8" title="1">st := reflect.TypeOf((*Observable)(nil))
        //fmt.Println(t, st)
        if t == st </span><span class="cov8" title="1">{
                o := newGeneratorObservable("From *Observable")

                o.flip = func(ctx context.Context, out chan interface{}) </span><span class="cov8" title="1">{
                        ro := v.Interface().(*Observable)
                        for ; ro.next != nil; ro = ro.next </span>{<span class="cov0" title="0">
                        }</span>
                        <span class="cov8" title="1">ro.mu.Lock()
                        ro.connect(ctx)
                        ch := ro.outflow
                        ro.mu.Unlock()
                        for item := range ch </span><span class="cov8" title="1">{
                                if b := o.sendToFlow(ctx, item, out); b </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov8" title="1">o.operator = fromObservable
                return o</span>
        }

        <span class="cov0" title="0">panic(ErrFuncFlip)</span>
}

// create an Observable that emits no items and does not terminate.
// It is important for combining with other Observables
func Never() *Observable <span class="cov8" title="1">{
        source := func(ctx context.Context, send func(x interface{}) (endSignal bool)) </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1"></span>
                }
        }
        <span class="cov8" title="1">o := Generator(source)
        o.Name = "Never"
        return o</span>
}

var emptySource = rangeSource
var throwSource = rangeSource

// create an Observable that emits no items but terminates normally
func Empty() *Observable <span class="cov8" title="1">{
        o := newGeneratorObservable("Empty")

        o.flip = func(ctx context.Context, out chan interface{}) </span>{<span class="cov8" title="1">
        }</span>
        <span class="cov8" title="1">o.operator = emptySource
        return o</span>
}

// create an Observable that emits no items and terminates with an error
func Throw(e error) *Observable <span class="cov8" title="1">{
        o := newGeneratorObservable("Throw")

        o.flip = func(ctx context.Context, out chan interface{}) </span><span class="cov8" title="1">{
                item := e
                o.sendToFlow(ctx, item, out)
        }</span>
        <span class="cov8" title="1">o.operator = throwSource
        return o</span>
}

func newGeneratorObservable(name string) (o *Observable) <span class="cov8" title="1">{
        //new Observable
        o = newObservable()
        o.Name = name

        //chain Observables
        o.root = o

        //set options
        o.buf_len = 0
        return o
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2018 The SS.SYSU Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package rxgo provides basic supporting to reactiveX of the Go.
package rxgo

import (
        "context"
        "errors"
        "reflect"
        "sync"
)

type ThreadModel uint

const (
        ThreadingDefault   ThreadModel = iota // one observable served by one goroutine
        ThreadingIO                           // each item served by one goroutine
        ThreadingComputing                    // each item served by one goroutine in a limited group
)

// Subscribe paeameter error
var ErrFuncOnNext = errors.New("Subscribe paramteter needs func(x anytype) or Observer or ObserverWithContext")

// operator func error
var ErrFuncFlip = errors.New("Operator Func Error")

// if user function throw EoFlow, the Observeable will stop and close it
var ErrEoFlow = errors.New("End of Flow!")

// if user function throw SkipItem, the Observeable will skip current item
var ErrSkipItem = errors.New("Skip item!")

// Error that can flow to subscriber or user function which processes error as an input
type FlowableError struct {
        Err      error
        Elements interface{}
}

func (e FlowableError) Error() string <span class="cov0" title="0">{
        return e.Err.Error()
}</span>

// Observer subscribes to an Observable. Then that observer reacts to whatever item or sequence of items the Observable emits.
type Observer interface {
        OnNext(x interface{})
        OnError(error)
        OnCompleted()
}

// Make Observables Context and support unsubscribe operation
type ObserverWithContext interface {
        Observer
        GetObserverContext() context.Context // you must create a cancelable context here when unsubscribe
        OnConnected()
        Unsubscribe()
}

// Create observer quickly with function
type ObserverMonitor struct {
        Next              func(x interface{})
        Error             func(error)
        Completed         func()
        Context           func() context.Context // an observer context musit gived when observables before connected
        AfterConnected    func()
        CancelObservables context.CancelFunc
}

func (o ObserverMonitor) OnNext(x interface{}) <span class="cov8" title="1">{
        if o.Next != nil </span><span class="cov8" title="1">{
                o.Next(x)
        }</span>
}

func (o ObserverMonitor) OnError(e error) <span class="cov8" title="1">{
        if o.Error != nil </span><span class="cov8" title="1">{
                o.Error(e)
        }</span>
}

func (o ObserverMonitor) OnCompleted() <span class="cov8" title="1">{
        if o.Completed != nil </span><span class="cov8" title="1">{
                o.Completed()
        }</span>
}

func (o ObserverMonitor) GetObserverContext() (c context.Context) <span class="cov8" title="1">{
        if o.Context != nil </span><span class="cov8" title="1">{
                return o.Context()
        }</span>
        <span class="cov8" title="1">return context.Background()</span>
}

func (o ObserverMonitor) OnConnected() <span class="cov8" title="1">{
        if o.AfterConnected != nil </span><span class="cov8" title="1">{
                o.AfterConnected()
        }</span>
}

func (o ObserverMonitor) Unsubscribe() <span class="cov8" title="1">{
        if o.CancelObservables != nil </span><span class="cov8" title="1">{
                o.CancelObservables()
        }</span>
}

type streamOperator interface {
        op(ctx context.Context, o *Observable)
}

//emit something
type sourceFunc func(ctx context.Context, send func(x interface{}) (endSignal bool))

//transform any item
type transformFunc func(ctx context.Context, item interface{}, send func(x interface{}) (endSignal bool))

// default buffer of channels
var BufferLen uint = 128

// An Observable is a 'collection of items that arrive over time'. Observables can be used to model asynchronous events.
// Observables can also be chained by operators to transformed, combined those items
// The Observable's operators, by default, run with a channel size of 128 elements except that the source (first) observable has no buffer
type Observable struct {
        Name string
        mu   sync.Mutex // lock all when creating subscriber
        //
        flip     interface{} // transformation function
        outflow  chan interface{}
        operator streamOperator
        // chain of Observables
        root *Observable
        next *Observable
        pred *Observable
        // control model
        threading ThreadModel //threading model. if this is root, it represents obseverOn model
        buf_len   uint
        // utility vars
        debug             Observer
        flip_sup_ctx      bool //indicate that flip function use context as first paramter
        flip_accept_error bool // indicate that flip function input's data is type interface{} or error
}

func newObservable() *Observable <span class="cov8" title="1">{
        return &amp;Observable{}
}</span>

// connect all Observable form the first one.
func (o *Observable) connect(ctx context.Context) <span class="cov8" title="1">{
        for po := o.root; po != nil; po = po.next </span><span class="cov8" title="1">{
                po.outflow = make(chan interface{}, po.buf_len)
                po.operator.op(ctx, po)
                //fmt.Println("conneted", po.name, po.outflow)
        }</span>
}

func (o *Observable) SubscribeOn(t ThreadModel) *Observable <span class="cov8" title="1">{
        o.threading = t
        return o
}</span>

func (o *Observable) ObserveOn(t ThreadModel) *Observable <span class="cov0" title="0">{
        po := o.root
        po.threading = t
        return o
}</span>

func (o *Observable) Subscribe(ob interface{}) <span class="cov8" title="1">{
        o.mu.Lock()
        fv, ft := reflect.ValueOf(ob), reflect.TypeOf(ob)

        var observer Observer

        // observe function `func(x anytype)`
        if fv.Kind() == reflect.Func </span><span class="cov8" title="1">{
                if ft.NumIn() == 1 &amp;&amp; ft.NumOut() != 0 </span><span class="cov0" title="0">{
                        panic(ErrFuncOnNext)</span>
                }
        } else<span class="cov8" title="1"> {
                st := reflect.TypeOf((*Observer)(nil)).Elem() // get type of *Observer
                //fmt.Println("ffffffffffffff", ft, st, ft.Implements(st))
                if ft.Implements(st) </span><span class="cov8" title="1">{
                        observer = ob.(Observer)
                }</span> else<span class="cov0" title="0"> {
                        panic(ErrFuncOnNext)</span>
                }
        }

        <span class="cov8" title="1">oc, ctxok := observer.(ObserverWithContext)
        ctx := context.Background()

        if ctxok </span><span class="cov8" title="1">{
                ctx = oc.GetObserverContext()
                //fmt.Println("ctx geted!", ctx)
        }</span>

        //fmt.Println("begin conneted", o.name)
        <span class="cov8" title="1">o.connect(ctx)
        if ctxok </span><span class="cov8" title="1">{
                oc.OnConnected()
        }</span>

        //get the last ob servable
        <span class="cov8" title="1">po := o
        for ; po.next != nil; po = po.next </span>{<span class="cov0" title="0">
        }</span>

        <span class="cov8" title="1">in := po.outflow
        o.mu.Unlock()

        for x := range in </span><span class="cov8" title="1">{
                if observer != nil </span><span class="cov8" title="1">{
                        if e, ok := x.(error); ok </span><span class="cov8" title="1">{
                                observer.OnError(e)

                        }</span> else<span class="cov8" title="1"> {
                                observer.OnNext(x)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if _, ok := x.(error); ok </span>{<span class="cov8" title="1">
                                // skip error
                        }</span> else<span class="cov8" title="1"> {
                                params := []reflect.Value{reflect.ValueOf(x)}
                                fv.Call(params)
                        }</span>
                }
        }
        <span class="cov8" title="1">if observer != nil </span><span class="cov8" title="1">{
                observer.OnCompleted()
        }</span>
}

func (o *Observable) SetBufferLen(length uint) *Observable <span class="cov0" title="0">{
        o.buf_len = length
        return o
}</span>

// set a observer to monite items in data stream
func (o *Observable) SetMonitor(observer Observer) *Observable <span class="cov0" title="0">{
        o.debug = observer
        return o
}</span>

// set a innerMonitor for debug
func (o *Observable) Debug(debug bool) *Observable <span class="cov8" title="1">{
        if debug &amp;&amp; o.debug == nil </span><span class="cov8" title="1">{
                o.debug = InnerObserver{o.Name + " debug "}
        }</span>
        <span class="cov8" title="1">if !debug &amp;&amp; o.debug != nil </span><span class="cov0" title="0">{
                o.debug = nil
        }</span>
        <span class="cov8" title="1">return o</span>
}

func (o *Observable) sendToFlow(ctx context.Context, item interface{}, out chan interface{}) (end bool) <span class="cov8" title="1">{
        //fmt.Println("send chan ", o.name, item, out)
        select </span>{
        case out &lt;- item:<span class="cov8" title="1">
                if e, ok := item.(error); ok </span><span class="cov8" title="1">{
                        if o.debug != nil </span><span class="cov0" title="0">{
                                o.debug.OnError(e)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if o.debug != nil </span><span class="cov8" title="1">{
                                o.debug.OnNext(item)
                        }</span>
                }
        case &lt;-ctx.Done():<span class="cov8" title="1">
                end = true</span>
        }
        <span class="cov8" title="1">return</span>
}

func (o *Observable) closeFlow(out chan interface{}) *Observable <span class="cov8" title="1">{
        // maybe need waiting for parent observable closed
        //fmt.Println("close chan ", o.name, out)
        close(out)
        if o.debug != nil </span><span class="cov8" title="1">{
                o.debug.OnCompleted()
        }</span>
        <span class="cov8" title="1">return o</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2018 The SS.SYSU Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rxgo

import (
        "context"
        "reflect"
        "sync"
)

var (
        typeAny        = reflect.TypeOf((*interface{})(nil)).Elem()
        typeContext    = reflect.TypeOf((*context.Context)(nil)).Elem()
        typeError      = reflect.TypeOf((*error)(nil)).Elem()
        typeBool       = reflect.TypeOf(true)
        typeObservable = reflect.TypeOf(&amp;Observable{})
)

// transform node implementation of streamOperator
type transOperater struct {
        opFunc func(ctx context.Context, o *Observable, item reflect.Value, out chan interface{}) (end bool)
}

func (tsop transOperater) op(ctx context.Context, o *Observable) <span class="cov8" title="1">{
        // must hold defintion of flow resourcs here, such as chan etc., that is allocated when connected
        // this resurces may be changed when operation routine is running.
        in := o.pred.outflow
        out := o.outflow
        //fmt.Println(o.name, "operator in/out chan ", in, out)
        var wg sync.WaitGroup

        go func() </span><span class="cov8" title="1">{
                end := false
                for x := range in </span><span class="cov8" title="1">{
                        if end </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // can not pass a interface as parameter (pointer) to gorountion for it may change its value outside!
                        <span class="cov8" title="1">xv := reflect.ValueOf(x)
                        // send an error to stream if the flip not accept error
                        if e, ok := x.(error); ok &amp;&amp; !o.flip_accept_error </span><span class="cov8" title="1">{
                                o.sendToFlow(ctx, e, out)
                                continue</span>
                        }
                        // scheduler
                        <span class="cov8" title="1">switch threading := o.threading; threading </span>{
                        case ThreadingDefault:<span class="cov8" title="1">
                                if tsop.opFunc(ctx, o, xv, out) </span><span class="cov0" title="0">{
                                        end = true
                                }</span>
                        case ThreadingIO:<span class="cov8" title="1">
                                fallthrough</span>
                        case ThreadingComputing:<span class="cov8" title="1">
                                wg.Add(1)
                                go func() </span><span class="cov8" title="1">{
                                        defer wg.Done()
                                        if tsop.opFunc(ctx, o, xv, out) </span><span class="cov0" title="0">{
                                                end = true
                                        }</span>
                                }()
                        default:<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov8" title="1">wg.Wait() //waiting all go-routines completed
                o.closeFlow(out)</span>
        }()
}

func (parent *Observable) TransformOp(tf transformFunc) (o *Observable) <span class="cov8" title="1">{
        o = parent.newTransformObservable("customTransform")
        o.flip_accept_error = true

        o.flip = tf
        o.flip_accept_error = true
        o.operator = transformOperater
        return o
}</span>

var transformOperater = transOperater{func(ctx context.Context, o *Observable, x reflect.Value, out chan interface{}) (end bool) <span class="cov8" title="1">{
        tf := o.flip.(transformFunc)
        send := func(x interface{}) (endSignal bool) </span><span class="cov8" title="1">{
                endSignal = o.sendToFlow(ctx, x, out)
                return
        }</span>
        <span class="cov8" title="1">tf(ctx, x.Interface(), send)
        return</span>
}}

// Map maps each item in Observable by the function with `func(x anytype) anytype` and
// returns a new Observable with applied items.
func (parent *Observable) Map(f interface{}) (o *Observable) <span class="cov8" title="1">{
        // check validation of f
        fv := reflect.ValueOf(f)
        inType := []reflect.Type{typeAny}
        outType := []reflect.Type{typeAny}
        b, ctx_sup := checkFuncUpcast(fv, inType, outType, true)
        if !b </span><span class="cov0" title="0">{
                panic(ErrFuncFlip)</span>
        }

        <span class="cov8" title="1">o = parent.newTransformObservable("map")
        o.flip_accept_error = checkFuncAcceptError(fv)

        o.flip_sup_ctx = ctx_sup
        o.flip = fv.Interface()
        o.operator = mapOperater
        return o</span>
}

var mapOperater = transOperater{func(ctx context.Context, o *Observable, x reflect.Value, out chan interface{}) (end bool) <span class="cov8" title="1">{

        fv := reflect.ValueOf(o.flip)
        var params = []reflect.Value{x}
        rs, skip, stop, e := userFuncCall(fv, params)

        var item interface{} = rs[0].Interface()
        if stop </span><span class="cov0" title="0">{
                end = true
                return
        }</span>
        <span class="cov8" title="1">if skip </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if e != nil </span><span class="cov0" title="0">{
                item = e
        }</span>
        // send data
        <span class="cov8" title="1">if !end </span><span class="cov8" title="1">{
                end = o.sendToFlow(ctx, item, out)
        }</span>

        <span class="cov8" title="1">return</span>
}}

// FlatMap maps each item in Observable by the function with `func(x anytype) (o *Observable) ` and
// returns a new Observable with merged observables appling on each items.
func (parent *Observable) FlatMap(f interface{}) (o *Observable) <span class="cov8" title="1">{
        // check validation of f
        fv := reflect.ValueOf(f)
        inType := []reflect.Type{typeAny}
        outType := []reflect.Type{typeObservable}
        b, ctx_sup := checkFuncUpcast(fv, inType, outType, true)
        if !b </span><span class="cov0" title="0">{
                panic(ErrFuncFlip)</span>
        }

        <span class="cov8" title="1">o = parent.newTransformObservable("flatMap")
        o.flip_accept_error = checkFuncAcceptError(fv)

        o.flip_sup_ctx = ctx_sup
        o.flip = fv.Interface()
        o.operator = flatMapOperater
        return o</span>
}

var flatMapOperater = transOperater{func(ctx context.Context, o *Observable, x reflect.Value, out chan interface{}) (end bool) <span class="cov8" title="1">{

        fv := reflect.ValueOf(o.flip)
        var params = []reflect.Value{x}
        //fmt.Println("x is ", x)
        rs, skip, stop, e := userFuncCall(fv, params)

        var item = rs[0].Interface().(*Observable)

        if stop </span><span class="cov0" title="0">{
                end = true
                return
        }</span>
        <span class="cov8" title="1">if skip </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if e != nil </span><span class="cov0" title="0">{
                end = o.sendToFlow(ctx, e, out)
                if end </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">return</span>
        }
        // send data
        <span class="cov8" title="1">if !end </span><span class="cov8" title="1">{
                if item != nil </span><span class="cov8" title="1">{
                        // subscribe ro without any ObserveOn model
                        ro := item
                        for ; ro.next != nil; ro = ro.next </span>{<span class="cov0" title="0">
                        }</span>
                        <span class="cov8" title="1">ro.connect(ctx)

                        ch := ro.outflow
                        for x := range ch </span><span class="cov8" title="1">{
                                end = o.sendToFlow(ctx, x, out)
                                if end </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}}

// Filter `func(x anytype) bool` filters items in the original Observable and returns
// a new Observable with the filtered items.
func (parent *Observable) Filter(f interface{}) (o *Observable) <span class="cov8" title="1">{
        // check validation of f
        fv := reflect.ValueOf(f)
        inType := []reflect.Type{typeAny}
        outType := []reflect.Type{typeBool}
        b, ctx_sup := checkFuncUpcast(fv, inType, outType, true)
        if !b </span><span class="cov0" title="0">{
                panic(ErrFuncFlip)</span>
        }

        <span class="cov8" title="1">o = parent.newTransformObservable("filter")
        o.flip_accept_error = checkFuncAcceptError(fv)

        o.flip_sup_ctx = ctx_sup
        o.flip = fv.Interface()
        o.operator = filterOperater
        return o</span>
}

var filterOperater = transOperater{func(ctx context.Context, o *Observable, x reflect.Value, out chan interface{}) (end bool) <span class="cov8" title="1">{

        fv := reflect.ValueOf(o.flip)
        var params = []reflect.Value{x}
        rs, skip, stop, e := userFuncCall(fv, params)

        var item interface{} = rs[0].Interface()
        if stop </span><span class="cov0" title="0">{
                end = true
                return
        }</span>
        <span class="cov8" title="1">if skip </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if e != nil </span><span class="cov0" title="0">{
                item = e
        }</span>
        // send data
        <span class="cov8" title="1">if !end </span><span class="cov8" title="1">{
                if b, ok := item.(bool); ok &amp;&amp; b </span><span class="cov8" title="1">{
                        end = o.sendToFlow(ctx, x.Interface(), out)
                }</span>
        }

        <span class="cov8" title="1">return</span>
}}

func (parent *Observable) newTransformObservable(name string) (o *Observable) <span class="cov8" title="1">{
        //new Observable
        o = newObservable()
        o.Name = name

        //chain Observables
        parent.next = o
        o.pred = parent
        o.root = parent.root

        //set options
        o.buf_len = BufferLen
        return o
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2018 The SS.SYSU Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rxgo

import (
        "fmt"
        "reflect"
)

// Test Observer
type InnerObserver struct {
        name string
}

var _ Observer = InnerObserver{"test"}

func (o InnerObserver) OnNext(x interface{}) <span class="cov8" title="1">{
        fmt.Println(o.name, "Receive value ", x)
}</span>

func (o InnerObserver) OnError(e error) <span class="cov0" title="0">{
        fmt.Println(o.name, "Error ", e)
}</span>

func (o InnerObserver) OnCompleted() <span class="cov8" title="1">{
        fmt.Println(o.name, "Down ")
}</span>

// func type check, such as `func(x int) bool` satisfied for `func(x anytype) bool`
func checkFuncUpcast(fv reflect.Value, inType, outType []reflect.Type, ctx_sup bool) (b, ctx_b bool) <span class="cov8" title="1">{
        //fmt.Println(fv.Kind(),reflect.Func)
        if fv.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return // Not func
        }</span>
        <span class="cov8" title="1">ft := fv.Type()
        if ft.NumOut() != len(outType) </span><span class="cov0" title="0">{
                return // Error result parameters
        }</span>
        <span class="cov8" title="1">if !ctx_sup </span><span class="cov0" title="0">{
                if ft.NumIn() != len(inType) </span><span class="cov0" title="0">{
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                if ft.NumIn() == 0 </span><span class="cov0" title="0">{
                        if len(inType) != 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                } else<span class="cov8" title="1"> {
                        if ft.In(0).Implements(typeContext) </span><span class="cov8" title="1">{
                                ctx_b = true
                                if ft.NumIn() != len(inType)+1 </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if ft.NumIn() != len(inType) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for i, t := range inType </span><span class="cov8" title="1">{
                var real_t reflect.Type
                if ctx_b </span><span class="cov0" title="0">{
                        real_t = ft.In(i + 1)
                }</span> else<span class="cov8" title="1"> {
                        real_t = ft.In(i)
                }</span>

                //todo: ptr or slice check
                <span class="cov8" title="1">switch </span>{
                case real_t == t:<span class="cov0" title="0"></span>
                case t.Kind() == reflect.Interface &amp;&amp; real_t.Implements(t):<span class="cov8" title="1"></span>
                //case ft.In(i).AssignableTo(t):
                //case ft.In(i).ConvertibleTo(t):
                default:<span class="cov0" title="0">
                        return</span>
                }
        }
        <span class="cov8" title="1">for i, t := range outType </span><span class="cov8" title="1">{
                //fmt.Println(ft.Out(i), t)
                //todo: ptr or slice check
                switch </span>{
                case ft.Out(i) == t:<span class="cov8" title="1"></span>
                case t.Kind() == reflect.Interface &amp;&amp; ft.Out(i).Implements(t):<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        return</span>
                }
        }
        <span class="cov8" title="1">b = true
        return</span>
}

// ckeck function the first parameter can accept error
func checkFuncAcceptError(fv reflect.Value) (b bool) <span class="cov8" title="1">{
        if fv.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return // Not func
        }</span>
        <span class="cov8" title="1">ft := fv.Type()
        if ft.NumIn() == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">i := 0 //ptr to first para
        if ft.In(0).Implements(typeContext) </span><span class="cov0" title="0">{
                i++
        }</span>
        <span class="cov8" title="1">if ft.NumIn() &lt;= i </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">t := ft.In(i)
        if t.Kind() == reflect.Interface &amp;&amp; (t.Implements(typeAny) || t.Implements(typeError)) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return</span>
}

// wrap exception when call user function
func userFuncCall(fv reflect.Value, params []reflect.Value) (res []reflect.Value, skip, stop bool, eout error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if e := recover(); e != nil </span><span class="cov8" title="1">{
                        if fe, ok := e.(FlowableError); ok </span><span class="cov8" title="1">{
                                eout = fe
                                return
                        }</span>
                        <span class="cov0" title="0">switch e </span>{
                        case ErrSkipItem:<span class="cov0" title="0">
                                skip = true
                                return</span>
                        case ErrEoFlow:<span class="cov0" title="0">
                                stop = true
                                return</span>
                        default:<span class="cov0" title="0">
                                panic(e)</span>
                        }
                }
        }()

        <span class="cov8" title="1">res = fv.Call(params)
        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
